import org.junit.jupiter.api.Test;
import java.util.List;
import static org.junit.jupiter.api.Assertions.*;

/**
 * EscapeTest202292352 is a class to test whether result generated by
 * EscapeImpl.java is valid.
 *
 * @version 1.0 01 Oct 2023
 * @author Xinghua Ren
 */
public class EscapeTest202292352 {
    private final Escape escape = new EscapeImpl();

    /* Test case 1: No entrance exists. Return false expected. */
    final char[][] maze1 = new char[][] {
        {' ', ' ', ' ', ' ', ' '},
        {' ', 'W', ' ', 'W', ' '},
        {' ', ' ', 'X', ' ', ' '},
        {' ', 'W', ' ', 'W', ' '},
        {' ', ' ', ' ', ' ', ' '},
    };

    /* Test case 2: No exit exists. Return false expected. */
    final char[][] maze2 = new char[][] {
        {' ', ' ', ' ', ' ', ' '},
        {' ', 'W', ' ', 'W', ' '},
        {' ', ' ', 'E', ' ', ' '},
        {' ', 'W', ' ', 'W', ' '},
        {' ', ' ', ' ', ' ', ' '},
    };

    /* Test case 3: No valid path exists. Return false expected. */
    final char[][] maze3 = new char[][] {
        {'E', ' ', 'W', ' ', ' '},
        {' ', ' ', 'W', ' ', ' '},
        {' ', ' ', 'W', ' ', ' '},
        {' ', ' ', 'W', ' ', ' '},
        {' ', ' ', 'W', ' ', 'X'},
    };

    /* Test case 4: Characters other than E, X, and W appear in maze.
     * Return false expected.
     */
    final char[][] maze4 = new char[][] {
        {'A', 'B', 'C', 'D', 'F'},
        {'Q', 'E', 'W', 'W', 'G'},
        {'P', 'W', 'W', 'W', 'H'},
        {'O', 'W', 'W', 'X', 'I'},
        {'N', 'M', 'L', 'K', 'J'},
    };

    /* Test case 5: Test if visited cells are removed during backtracking
     * with clockwise search. Return true expected.
     */
    final char[][] maze5 = new char[][] {
        {' ', ' ', 'E', ' ', ' '},
        {' ', 'W', 'W', 'W', ' '},
        {' ', 'W', 'X', 'W', ' '},
        {' ', 'W', ' ', 'W', ' '},
        {' ', ' ', ' ', 'W', ' '},
    };

    /* Test case 6: Test if visited cells are removed during backtracking
     * with counterclockwise search. Return true expected.
     */
    final char[][] maze6 = new char[][] {
        {' ', ' ', 'E', ' ', ' '},
        {' ', 'W', 'W', 'W', ' '},
        {' ', 'W', 'X', 'W', ' '},
        {' ', 'W', ' ', 'W', ' '},
        {' ', 'W', ' ', ' ', ' '},
    };

    /* Test case 7: Exit is not next to a wall. Return true expected. */
    final char[][] maze7 = new char[][] {
        {'E', ' ', ' ', ' ', ' '},
        {' ', 'W', 'W', 'W', 'W'},
        {' ', ' ', ' ', ' ', ' '},
        {' ', 'W', ' ', 'X', ' '},
        {' ', 'W', ' ', ' ', ' '},
    };

    /* Test case 8: Entrance and exit are next to each other. Return true expected. */
    final char[][] maze8 = new char[][] {
        {' ', ' ', ' ', ' ', ' '},
        {' ', ' ', ' ', ' ', ' '},
        {' ', ' ', ' ', ' ', ' '},
        {' ', ' ', ' ', ' ', ' '},
        {' ', ' ', ' ', 'E', 'X'},
    };

    /* JUnit test to check if result is valid or as expected. */
    @Test
    public void testCase1() {
        final List<Pair<Integer, Integer>> result = escape.escape(maze1);
        assertFalse(testPath(result, maze1));
    }

    @Test
    public void testCase2() {
        final List<Pair<Integer, Integer>> result = escape.escape(maze2);
        assertFalse(testPath(result, maze2));
    }

    @Test
    public void testCase3() {
        final List<Pair<Integer, Integer>> result = escape.escape(maze3);
        assertFalse(testPath(result, maze3));
    }

    @Test
    public void testCase4() {
        final List<Pair<Integer, Integer>> result = escape.escape(maze4);
        assertFalse(testPath(result, maze4));
    }

    @Test
    public void testCase5() {
        final List<Pair<Integer, Integer>> result = escape.escape(maze5);
        assertTrue(testPath(result, maze5));
    }

    @Test
    public void testCase6() {
        final List<Pair<Integer, Integer>> result = escape.escape(maze6);
        assertTrue(testPath(result, maze6));
    }

    @Test
    public void testCase7() {
        final List<Pair<Integer, Integer>> result = escape.escape(maze7);
        assertTrue(testPath(result, maze7));
    }

    @Test
    public void testCase8() {
        final List<Pair<Integer, Integer>> result = escape.escape(maze8);
        assertTrue(testPath(result, maze8));
    }

    /**
     * testPath is a method that traversed the whole path list to check if all
     * following four conditions are true:
     * 1. Coordinates of items in path list can actually form a continuous path.
     * 2. First item of list is coordinate for entrance.
     * 3. Last item of list is coordinate for exit.
     * 4. All other items in between are coordinates for empty cells.
     *
     * @param path The list of path to be tested.
     * @param maze The given maze to be tested.
     * @return     True if all four conditions are met. Return false if any of these
     *             conditions is not met.
     */
    private boolean testPath(List<Pair<Integer, Integer>> path, char[][] maze) {

        /* Path is an empty list when no entrance or no exit or no valid path exists. */
        if (!path.isEmpty()) {

            /* Test whether coordinates of items in path list can actually form
             * a continuous path. Return false if jump beyond neighboring items happens.
             */
            for (int i = 0; i < path.size() - 1; i++) {
                int m = path.get(i).first;
                int n = path.get(i).second;
                int p = path.get(i + 1).first;
                int q = path.get(i + 1).second;
                if ( Math.abs(m - p) + Math.abs(n - q) != 1) {
                    return false;
                }
            }

            /* Test if first item of path list is coordinate for exit. */
            final Pair<Integer, Integer> exitCoordinate = path.remove(0);
            if (maze[exitCoordinate.first][exitCoordinate.second] != 'X') {
                return false;
            }

            /* Test if all items in between are coordinates for empty cells. */
            while (path.size() > 1) {
                final Pair<Integer, Integer> coordinate = path.remove(0);
                if (maze[coordinate.first][coordinate.second] != ' ') {
                    return false;
                }
            }

            /* Test if last item of path list is coordinate for entrance. */
            final Pair<Integer, Integer> entranceCoordinate = path.remove(0);
            if (maze[entranceCoordinate.first][entranceCoordinate.second] != 'E') {
                return false;
            }

            /* Return true if all four conditions are met. */
            return true;
        }
        /* Return false if path is an empty list. */
        return false;
    }
}